<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La C√† Beverage - Admin Dashboard</title>
    <style>
    /* Mobile-First Admin Dashboard CSS */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
    }
	/* Date Filter Styles */
.date-filter-section {
    background: rgba(255, 255, 255, 0.95);
    padding: 12px;
    border-radius: 8px;
    margin-bottom: 16px;
    backdrop-filter: blur(5px);
    border: 1px solid rgba(0,0,0,0.1);
}

.filter-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
}

.filter-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.filter-group label {
    font-size: 0.8rem;
    font-weight: 600;
    color: #2c3e50;
}

.filter-group select,
.filter-group input {
    padding: 6px 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.8rem;
    background: white;
}

.custom-date {
    flex-direction: row;
    align-items: center;
    gap: 8px;
}

.custom-date label {
    font-size: 0.75rem;
    margin: 0;
}

.custom-date input {
    padding: 4px 6px;
    font-size: 0.75rem;
}

.filter-stats {
    background: rgba(39, 174, 96, 0.1);
    padding: 6px 12px;
    border-radius: 12px;
    font-size: 0.75rem;
    color: #27ae60;
    font-weight: 600;
    border: 1px solid rgba(39, 174, 96, 0.3);
}

/* Mobile optimizations for filter */
@media (max-width: 768px) {
    .filter-controls {
        flex-direction: column;
        align-items: stretch;
    }
    
    .filter-group {
        width: 100%;
    }
    
    .custom-date {
        flex-direction: column;
        align-items: stretch;
    }
    
    .filter-group select,
    .filter-group input {
        font-size: 16px; /* Prevent zoom on iOS */
    }
}

    
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #333;
        line-height: 1.5;
        overflow-x: hidden;
        min-height: 100vh;
    }
    
    /* Mobile Header - Sticky Navigation */
    .header {
        background: rgba(255, 255, 255, 0.95);
        padding: 12px 16px;
        backdrop-filter: blur(20px);
        position: sticky;
        top: 0;
        z-index: 1000;
        border-bottom: 1px solid rgba(0,0,0,0.1);
    }
    
    .header h1 {
        color: #2c3e50;
        font-size: 1.2rem;
        text-align: center;
        font-weight: 700;
    }
    
    .container {
        max-width: 100%;
        padding: 16px;
        margin: 0;
    }
    
    /* Mobile Stats Grid - 2x2 Layout */
    .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 20px;
    }
    
    .stat-card {
        background: rgba(255, 255, 255, 0.95);
        padding: 16px 12px;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        text-align: center;
        transition: transform 0.2s ease;
        backdrop-filter: blur(10px);
        min-height: 80px;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }
    
    .stat-card:active {
        transform: scale(0.98);
    }
    
    .stat-number {
        font-size: 1.8rem;
        font-weight: 800;
        color: #e74c3c;
        margin-bottom: 4px;
        line-height: 1;
    }
    
    .stat-label {
        color: #7f8c8d;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-weight: 600;
    }
    
    .stat-note {
        font-size: 0.65rem;
        color: #95a5a6;
        margin-top: 2px;
        font-style: italic;
    }
    
    /* Mobile Bottom Navigation */
    .tabs {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border-top: 1px solid rgba(0,0,0,0.1);
        display: flex;
        z-index: 1000;
        padding-bottom: env(safe-area-inset-bottom);
    }
    
    .tab {
        flex: 1;
        padding: 12px 8px;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 0.7rem;
        font-weight: 600;
        transition: all 0.2s ease;
        color: #7f8c8d;
        text-align: center;
        min-height: 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
    }
    
    .tab.active {
        color: #e74c3c;
        background: rgba(231, 76, 60, 0.1);
    }
    
    .tab:active {
        transform: scale(0.95);
    }
    
    .tab-icon {
        font-size: 1.2rem;
        line-height: 1;
    }
    
    /* Content Area with Bottom Padding */
    .tab-content {
        background: rgba(255, 255, 255, 0.95);
        margin-bottom: 80px; /* Space for bottom nav */
        border-radius: 16px 16px 0 0;
        backdrop-filter: blur(10px);
        box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
        min-height: 60vh;
    }
    
    .tab-pane {
        display: none;
        padding: 20px 16px;
    }
    
    .tab-pane.active {
        display: block;
    }
    
    .tab-pane h2 {
        font-size: 1.3rem;
        color: #2c3e50;
        margin-bottom: 16px;
        font-weight: 700;
    }
    
    /* Mobile Orders Table */
    .orders-container {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        margin: 0 -16px;
        padding: 0 16px;
    }
    
    .orders-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.8rem;
        min-width: 700px;
    }
    
    .orders-table th,
    .orders-table td {
        padding: 12px 8px;
        text-align: left;
        border-bottom: 1px solid #eee;
        vertical-align: top;
    }
    
    .orders-table th {
        background: rgba(248, 249, 250, 0.8);
        font-weight: 700;
        color: #2c3e50;
        font-size: 0.75rem;
        position: sticky;
        top: 0;
        z-index: 10;
        backdrop-filter: blur(10px);
    }
    
    .orders-table tr:hover {
        background: rgba(248, 249, 250, 0.5);
    }
    
    /* Ultra Compact Order Cards for Mobile */
.order-card {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 10px;
    margin-bottom: 8px;
    border-left: 3px solid #e74c3c;
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    backdrop-filter: blur(5px);
    font-size: 0.8rem;
    max-height: 140px; /* Gi·ªõi h·∫°n chi·ªÅu cao */
    overflow: hidden;
}

.order-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
    padding-bottom: 4px;
    border-bottom: 1px solid #eee;
}

.order-id {
    font-weight: 700;
    color: #2c3e50;
    font-size: 0.9rem;
}

.order-time {
    font-size: 0.65rem;
    color: #7f8c8d;
    text-align: right;
    line-height: 1.2;
    max-width: 80px;
}

.order-details {
    font-size: 0.75rem;
    color: #555;
    margin-bottom: 8px;
    line-height: 1.3;
    max-height: 60px; /* Gi·ªõi h·∫°n chi·ªÅu cao details */
    overflow: hidden;
    text-overflow: ellipsis;
}

.order-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 6px;
    margin-top: auto;
}

.order-actions {
    display: flex;
    gap: 4px;
}

.order-actions .btn {
    padding: 4px 8px;
    font-size: 0.7rem;
    min-height: 28px;
    min-width: 32px;
    border-radius: 4px;
}

/* Status badges compact */
.status-badge {
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 0.65rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    white-space: nowrap;
}
/* Enhanced Order Cards with Better Notes Display */
.order-card {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    border-left: 3px solid #e74c3c;
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    backdrop-filter: blur(5px);
    font-size: 0.8rem;
    max-height: none; /* Remove height limit for notes */
    overflow: visible; /* Allow notes to be fully visible */
}

.order-notes {
    background: rgba(255, 249, 196, 0.8);
    padding: 6px 8px;
    border-radius: 4px;
    margin: 6px 0;
    border-left: 2px solid #f39c12;
    font-size: 0.75rem;
    line-height: 1.4;
    color: #856404;
    max-height: none; /* Remove height restriction */
    overflow: visible; /* Show full notes */
    word-wrap: break-word; /* Handle long text */
}

.order-details {
    font-size: 0.75rem;
    color: #555;
    margin-bottom: 10px;
    line-height: 1.4;
    max-height: none; /* Remove height restriction */
    overflow: visible; /* Show all content */
}

.order-time {
    font-size: 0.7rem;
    color: #7f8c8d;
    text-align: right;
    line-height: 1.2;
    max-width: 100px;
}

.order-time small {
    color: #95a5a6;
    font-size: 0.65rem;
}

/* Enhanced Action Buttons */
.order-actions .btn {
    padding: 4px 8px;
    font-size: 0.65rem;
    min-height: 26px;
    min-width: 36px;
    border-radius: 4px;
    margin: 0 2px;
}

.btn-success {
    background: #28a745;
    color: white;
    border: none;
}

.btn-danger {
    background: #dc3545;
    color: white;
    border: none;
}

/* Mobile specific optimizations */
@media (max-width: 768px) {
    .order-card {
        margin-bottom: 10px;
        padding: 10px;
        max-height: none; /* No height limit on mobile */
    }
    
    .order-notes {
        margin: 8px 0;
        padding: 8px;
        font-size: 0.8rem; /* Larger text for notes */
    }
    
    .order-details {
        max-height: none;
        font-size: 0.75rem;
    }
    
    .order-time {
        max-width: 120px;
        font-size: 0.75rem;
    }
}

/* Extra small screens */
@media (max-width: 480px) {
    .order-card {
        max-height: 100px;
        padding: 6px;
        margin-bottom: 4px;
    }
    
    .order-details {
        max-height: 35px;
        font-size: 0.65rem;
    }
    
    .order-header {
        margin-bottom: 4px;
    }
    
    .order-footer {
        gap: 4px;
    }
    
    .order-actions .btn {
        padding: 2px 4px;
        font-size: 0.6rem;
        min-height: 20px;
        min-width: 24px;
    }
}

    
    /* Status Badges */
    .status-badge {
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 0.7rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .status-pending {
        background: #fff3cd;
        color: #856404;
    }
    
    .status-completed {
        background: #d4edda;
        color: #155724;
    }
    
    .status-cancelled {
        background: #f8d7da;
        color: #721c24;
    }
    
    /* Mobile Buttons */
    .btn {
        padding: 8px 16px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: 600;
        margin: 2px;
        transition: all 0.2s ease;
        min-height: 36px;
        min-width: 60px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
    }
    
    .btn:active {
        transform: scale(0.95);
    }
    
    .btn-success {
        background: #28a745;
        color: white;
    }
    
    .btn-danger {
        background: #dc3545;
        color: white;
    }
    
    .btn-primary {
        background: #007bff;
        color: white;
    }
    
    /* Menu Management - Mobile Grid */
    .add-item-form {
        background: rgba(248, 249, 250, 0.8);
        padding: 16px;
        border-radius: 12px;
        margin-bottom: 20px;
    }
    
    .add-item-form h3 {
        margin-bottom: 16px;
        color: #2c3e50;
        font-size: 1.1rem;
    }
    
    .form-grid {
        display: grid;
        gap: 12px;
    }
    
    .form-group {
        margin-bottom: 12px;
    }
    
    .form-group label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
        color: #2c3e50;
        font-size: 0.9rem;
    }
    
    .form-group input,
    .form-group select {
        width: 100%;
        padding: 12px;
        border: 2px solid #dee2e6;
        border-radius: 8px;
        font-size: 16px; /* Prevent zoom on iOS */
        background: rgba(255, 255, 255, 0.9);
        transition: border-color 0.2s ease;
    }
    
    .form-group input:focus,
    .form-group select:focus {
        outline: none;
        border-color: #e74c3c;
        box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.1);
    }
    
    /* Menu Cards Grid */
    .menu-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        margin-top: 16px;
    }
    
    .menu-item-card {
        background: rgba(248, 249, 250, 0.8);
        padding: 16px;
        border-radius: 12px;
        border: 1px solid #dee2e6;
        transition: all 0.2s ease;
    }
    
    .menu-item-card:active {
        transform: scale(0.98);
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    
    .menu-item-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 12px;
    }
    
    .menu-item-name {
        color: #2c3e50;
        font-weight: 700;
        font-size: 1rem;
        margin: 0;
        flex: 1;
    }
    
    .menu-item-category {
        background: #e74c3c;
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.7rem;
        font-weight: 600;
        margin-left: 8px;
    }
    
    .menu-item-price {
        font-size: 1.2rem;
        color: #e74c3c;
        font-weight: 700;
        margin-bottom: 12px;
    }
    
    .menu-item-actions {
        display: flex;
        gap: 8px;
    }
    
    /* Loading States */
    .loading {
        text-align: center;
        padding: 40px 20px;
        color: #6c757d;
        font-size: 0.9rem;
    }
    
    .loading::before {
        content: "";
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #e74c3c;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 8px;
        vertical-align: middle;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    /* Messages */
    .error, .success {
        padding: 12px 16px;
        border-radius: 8px;
        margin: 12px 0;
        font-size: 0.9rem;
        font-weight: 500;
        position: fixed;
        top: 80px;
        left: 16px;
        right: 16px;
        z-index: 2000;
        animation: slideDown 0.3s ease;
    }
    
    .error {
        background: rgba(248, 215, 218, 0.95);
        color: #721c24;
        border: 1px solid #f5c6cb;
    }
    
    .success {
        background: rgba(212, 237, 218, 0.95);
        color: #155724;
        border: 1px solid #c3e6cb;
    }
    
    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    /* Refresh Button */
    .refresh-btn {
        position: fixed;
        top: 80px;
        right: 16px;
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: #e74c3c;
        color: white;
        border: none;
        font-size: 1.2rem;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        transition: all 0.2s ease;
        z-index: 999;
    }
    
    .refresh-btn:active {
        transform: scale(0.9);
    }
    
    /* Swipe Gestures */
    .swipe-container {
        position: relative;
        overflow: hidden;
    }
    
    .swipe-actions {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        background: #dc3545;
        color: white;
        display: flex;
        align-items: center;
        padding: 0 16px;
        transform: translateX(100%);
        transition: transform 0.3s ease;
    }
    
    .swipe-container.swiped .swipe-actions {
        transform: translateX(0);
    }
    
    /* Tablet Responsive */
    @media (min-width: 768px) {
        .container {
            padding: 20px;
        }
        
        .stats-grid {
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
        }
        
        .tabs {
            position: static;
            background: white;
            border-radius: 12px 12px 0 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex-direction: row;
        }
        
        .tab {
            flex-direction: row;
            gap: 8px;
            min-height: 50px;
        }
        
        .tab-content {
            margin-bottom: 0;
            border-radius: 0 0 12px 12px;
        }
        
        .menu-grid {
            grid-template-columns: repeat(2, 1fr);
        }
        
        .orders-cards {
            display: none;
        }
        
        .orders-table {
            min-width: auto;
        }
    }
    
    /* Desktop Responsive */
    @media (min-width: 1024px) {
        .container {
            max-width: 1200px;
            margin: 20px auto;
        }
        
        .stats-grid {
            grid-template-columns: repeat(5, 1fr);
        }
        
        .menu-grid {
            grid-template-columns: repeat(3, 1fr);
        }
        
        .form-grid {
            grid-template-columns: 2fr 1fr 2fr 1fr;
            align-items: end;
        }
    }
    
    /* Dark Mode Support */
    @media (prefers-color-scheme: dark) {
        body {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
        }
        
        .header,
        .tab-content,
        .stat-card,
        .tabs {
            background: rgba(52, 73, 94, 0.95);
            color: #ecf0f1;
        }
        
        .tab-pane h2,
        .stat-number,
        .order-id,
        .menu-item-name {
            color: #ecf0f1;
        }
    }
    
    /* iPhone X+ Safe Area */
    @supports (padding: max(0px)) {
        .header {
            padding-top: max(12px, env(safe-area-inset-top));
        }
        
        .tabs {
            padding-bottom: max(12px, env(safe-area-inset-bottom));
        }
    }
    
    /* Hide scrollbars on mobile */
    .orders-container::-webkit-scrollbar {
        display: none;
    }
    
    .orders-container {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }
</style>

</head>
<body>
    <header class="header">
        <h1>üçπ La C√† Beverage - Admin Dashboard</h1>
    </header>

    <div class="container">
        <div class="stats-grid" id="statsGrid">
            <div class="stat-card">
                <div class="stat-number" id="totalOrders">-</div>
                <div class="stat-label">T·ªïng ƒë∆°n h√†ng</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="totalRevenue">-K</div>
                <div class="stat-label">Doanh thu th·ª±c t·∫ø</div>
                <div class="stat-note">(Ch·ªâ ƒë∆°n ho√†n th√†nh)</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="pendingOrders">-</div>
                <div class="stat-label">ƒêang ch·ªù x·ª≠ l√Ω</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="completedOrders">-</div>
                <div class="stat-label">ƒê√£ ho√†n th√†nh</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="cancelledOrders">-</div>
                <div class="stat-label">ƒê√£ h·ªßy</div>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="showTab('orders')">üìã Qu·∫£n l√Ω ƒë∆°n h√†ng</button>
            <button class="tab" onclick="showTab('menu')">üçΩÔ∏è Qu·∫£n l√Ω menu</button>
            <button class="tab" onclick="showTab('analytics')">üìä Th·ªëng k√™</button>
        </div>

        <div class="tab-content">
            <div id="ordersTab" class="tab-pane active">
                <h2>Danh s√°ch ƒë∆°n h√†ng</h2>
		 <div class="date-filter-section">
        <div class="filter-controls">
            <div class="filter-group">
                <label for="dateFilter">L·ªçc theo ng√†y:</label>
                <select id="dateFilter" onchange="filterOrdersByDate()">
                    <option value="all">T·∫•t c·∫£ ƒë∆°n h√†ng</option>
                    <option value="today">H√¥m nay</option>
                    <option value="yesterday">H√¥m qua</option>
                    <option value="this-week">Tu·∫ßn n√†y</option>
                    <option value="custom">Ch·ªçn ng√†y t√πy ch·ªânh</option>
                </select>
            </div>
            
            <div class="filter-group custom-date" id="customDateInputs" style="display: none;">
                <label for="startDate">T·ª´ ng√†y:</label>
                <input type="date" id="startDate" onchange="filterOrdersByDate()">
                <label for="endDate">ƒê·∫øn ng√†y:</label>
                <input type="date" id="endDate" onchange="filterOrdersByDate()">
            </div>
            
            <div class="filter-stats" id="filterStats"></div>
        </div>
    </div>
    
    <div id="ordersContent">
        <div class="loading">ƒêang t·∫£i d·ªØ li·ªáu...</div>
    </div>
</div>
            </div>

            <div id="menuTab" class="tab-pane">
                <h2>Qu·∫£n l√Ω menu</h2>
                
                <div class="add-item-form">
                    <h3>Th√™m m√≥n m·ªõi</h3>
                    <div style="display: grid; grid-template-columns: 2fr 1fr 2fr 1fr; gap: 1rem; align-items: end;">
                        <div class="form-group">
                            <label for="newItemName">T√™n m√≥n</label>
                            <input type="text" id="newItemName" placeholder="VD: Tr√† s·ªØa matcha">
                        </div>
                        <div class="form-group">
                            <label for="newItemPrice">Gi√° (K)</label>
                            <input type="number" id="newItemPrice" placeholder="35">
                        </div>
                        <div class="form-group">
                            <label for="newItemCategory">Danh m·ª•c</label>
                            <select id="newItemCategory">
                                <option value="CAFE">‚òï CAFE</option>
                                <option value="N∆Ø·ªöC √âP">ü•§ N∆Ø·ªöC √âP</option>
                                <option value="TR√Ä">üçÉ TR√Ä</option>
                                <option value="TR√Ä S·ªÆA">üßã TR√Ä S·ªÆA</option>
                                <option value="S·ªÆA CHUA L·∫ÆC">ü•õ S·ªÆA CHUA L·∫ÆC</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <button class="btn btn-primary" onclick="addNewMenuItem()">Th√™m m√≥n</button>
                        </div>
                    </div>
                </div>

                <div id="menuContent">
                    <div class="loading">ƒêang t·∫£i menu...</div>
                </div>
            </div>

            <div id="analyticsTab" class="tab-pane">
                <h2>Th·ªëng k√™ chi ti·∫øt</h2>
                <div id="analyticsContent">
                    <div class="loading">ƒêang t·∫£i th·ªëng k√™...</div>
                </div>
            </div>
        </div>
    </div>

    <button class="refresh-btn" onclick="refreshData()" title="L√†m m·ªõi d·ªØ li·ªáu">üîÑ</button>

    <script>
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwqpd2Pt2DFrEmiCxPvosEF_QC-SbBrPc1HbB_JW-bOsm_AA9zmh7hETwX9x4pZRWHtlQ/exec';
        let allOrders = []; // To store all fetched orders
        let currentOrders = [];
        let currentMenu = [];
        let currentFilter = 'today'; // Default filter

        // Kh·ªüi t·∫°o khi trang load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üçπ La C√† Admin Dashboard loaded');
            refreshData();
            // Auto refresh m·ªói 30 gi√¢y
            setInterval(refreshData, 30000);
        });

        // L√†m m·ªõi t·∫•t c·∫£ d·ªØ li·ªáu
        async function refreshData() {
            await Promise.all([
                loadStats(),
                loadOrders(),
                loadMenu()
            ]);
        }

        // Hi·ªÉn th·ªã tab
        function showTab(tabName) {
            // ·∫®n t·∫•t c·∫£ tab
            document.querySelectorAll('.tab-pane').forEach(pane => {
                pane.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Hi·ªÉn th·ªã tab ƒë∆∞·ª£c ch·ªçn
            document.getElementById(tabName + 'Tab').classList.add('active');
            event.target.classList.add('active');
        }

        // Load th·ªëng k√™ - ƒê√É S·ª¨A ƒê·ªÇ HI·ªÇN TH·ªä C·∫¢ ƒê·ª†N H·ª¶Y
        async function loadStats() {
            try {
                const response = await fetch(`${SCRIPT_URL}?action=getStats`);
                const result = await response.json();
                if (result.success) {
                    const stats = result.data;
                    document.getElementById('totalOrders').textContent = stats.totalOrders;
                    document.getElementById('totalRevenue').textContent = stats.totalRevenue + 'K';
                    document.getElementById('pendingOrders').textContent = stats.pendingOrders;
                    document.getElementById('completedOrders').textContent = stats.completedOrders;
                    document.getElementById('cancelledOrders').textContent = stats.cancelledOrders || 0;
                }
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        // S·ª≠a function loadOrders ƒë·ªÉ c√≥ fallback
        async function loadOrders() {
            try {
                const response = await fetch(`${SCRIPT_URL}?action=getOrders`);
                const result = await response.json();
                console.log('Load orders result:', result); // Debug log
                if (result.success) {
                    allOrders = result.data; // Store all orders
                    filterOrdersByDate(); // Apply current filter after loading
                } else {
                    throw new Error(result.error || 'Failed to load orders');
                }
            } catch (error) {
                console.error('Error loading orders:', error);
                document.getElementById('ordersContent').innerHTML = '<div class="error">L·ªói t·∫£i ƒë∆°n h√†ng: ' + error.message + '</div>';
            }
        }

        // Date filtering function
        function filterOrdersByDate() {
            const filterValue = document.getElementById('dateFilter').value;
            const customDateInputs = document.getElementById('customDateInputs');
            const filterStats = document.getElementById('filterStats');
            
            currentFilter = filterValue;
            
            // Show/hide custom date inputs
            if (filterValue === 'custom') {
                customDateInputs.style.display = 'flex';
                initializeDateInputs();
            } else {
                customDateInputs.style.display = 'none';
            }
            
            // Filter orders based on selection
            let filteredOrders = [];
            const today = new Date();
            const todayStr = formatDateForComparison(today);
            
            switch (filterValue) {
                case 'all':
                    filteredOrders = allOrders;
                    break;
                    
                case 'today':
                    filteredOrders = allOrders.filter(order => {
                        const orderDate = extractDateFromOrder(order);
                        return orderDate === todayStr;
                    });
                    break;
                    
                case 'yesterday':
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);
                    const yesterdayStr = formatDateForComparison(yesterday);
                    filteredOrders = allOrders.filter(order => {
                        const orderDate = extractDateFromOrder(order);
                        return orderDate === yesterdayStr;
                    });
                    break;
                    
                case 'this-week':
                    const startOfWeek = new Date(today);
                    startOfWeek.setDate(today.getDate() - today.getDay()); // Sunday as first day
                    startOfWeek.setHours(0,0,0,0); // Normalize to start of day
                    filteredOrders = allOrders.filter(order => {
                        const orderDate = new Date(convertOrderDateToDate(order));
                        orderDate.setHours(0,0,0,0); // Normalize order date to start of day
                        return orderDate >= startOfWeek && orderDate <= today;
                    });
                    break;
                    
                case 'custom':
                    const startDate = document.getElementById('startDate').value;
                    const endDate = document.getElementById('endDate').value;
                    
                    if (startDate && endDate) {
                        filteredOrders = allOrders.filter(order => {
                            const orderDate = extractDateFromOrder(order);
                            return orderDate >= startDate && orderDate <= endDate;
                        });
                    } else {
                        filteredOrders = []; // No custom dates selected yet, show nothing or all depending on desired default
                    }
                    break;
                    
                default:
                    filteredOrders = allOrders;
            }
            
            // Update filter stats
            updateFilterStats(filteredOrders.length, allOrders.length, filterValue);
            
            // Display filtered orders
            currentOrders = filteredOrders; // Update currentOrders after filtering
            displayOrders(filteredOrders);
        }

        // Helper functions for date filtering
        function extractDateFromOrder(order) {
            const timeStr = order['Th·ªùi gian ƒë·∫∑t'] || '';
            // Format: "20:30:45 23/6/2025" or "23/6/2025"
            const datePart = timeStr.includes(' ') ? timeStr.split(' ')[1] : timeStr;
            
            if (datePart.includes('/')) {
                const [day, month, year] = datePart.split('/');
                return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            }
            
            return '';
        }

        function convertOrderDateToDate(order) {
            const timeStr = order['Th·ªùi gian ƒë·∫∑t'] || '';
            const datePart = timeStr.includes(' ') ? timeStr.split(' ')[1] : timeStr;
            
            if (datePart.includes('/')) {
                const [day, month, year] = datePart.split('/');
                return new Date(year, month - 1, day);
            }
            
            return new Date();
        }

        function formatDateForComparison(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function initializeDateInputs() {
            const startDate = document.getElementById('startDate');
            const endDate = document.getElementById('endDate');
            
            if (!startDate.value) {
                const today = new Date();
                const weekAgo = new Date(today);
                weekAgo.setDate(today.getDate() - 7);
                
                startDate.value = formatDateForComparison(weekAgo);
                endDate.value = formatDateForComparison(today);
            }
        }

        function updateFilterStats(filteredCount, totalCount, filterType) {
            const filterStats = document.getElementById('filterStats');
            
            let message = '';
            switch (filterType) {
                case 'all':
                    message = `T·∫•t c·∫£ ${totalCount} ƒë∆°n h√†ng`;
                    break;
                case 'today':
                    message = `${filteredCount} ƒë∆°n h√¥m nay`;
                    break;
                case 'yesterday':
                    message = `${filteredCount} ƒë∆°n h√¥m qua`;
                    break;
                case 'this-week':
                    message = `${filteredCount} ƒë∆°n tu·∫ßn n√†y`;
                    break;
                case 'custom':
                    const startDate = document.getElementById('startDate').value;
                    const endDate = document.getElementById('endDate').value;
                    if (startDate && endDate) {
                        message = `${filteredCount} ƒë∆°n t·ª´ ${startDate} ƒë·∫øn ${endDate}`;
                    } else {
                        message = `Ch·ªçn ng√†y t√πy ch·ªânh`;
                    }
                    break;
                default:
                    message = `${filteredCount}/${totalCount} ƒë∆°n h√†ng`;
            }
            
            filterStats.textContent = message;
            
            // Hide if no orders
            if (filteredCount === 0 && filterType !== 'all') {
                filterStats.style.background = 'rgba(231, 76, 60, 0.1)';
                filterStats.style.color = '#e74c3c';
                filterStats.style.borderColor = 'rgba(231, 76, 60, 0.3)';
            } else {
                filterStats.style.background = 'rgba(39, 174, 96, 0.1)';
                filterStats.style.color = '#27ae60';
                filterStats.style.borderColor = 'rgba(39, 174, 96, 0.3)';
            }
        }


        // Hi·ªÉn th·ªã danh s√°ch ƒë∆°n h√†ng
        function displayOrders(orders) {
            const container = document.getElementById('ordersContent');
            if (!orders || orders.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 2rem;">Ch∆∞a c√≥ ƒë∆°n h√†ng n√†o</p>';
                return;
            }

            // S·∫Øp x·∫øp theo Order ID gi·∫£m d·∫ßn (m·ªõi nh·∫•t tr∆∞·ªõc)
            orders.sort((a, b) => (b['Order ID'] || 0) - (a['Order ID'] || 0));

            let html = `
                <table class="orders-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Th·ªùi gian</th>
                            <th>Kh√°ch h√†ng</th>
                            <th>Chi ti·∫øt m√≥n</th>
                            <th>T·ªïng ti·ªÅn</th>
                            <th>Ghi ch√∫</th>
                            <th>Tr·∫°ng th√°i</th>
                            <th>Thao t√°c</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            orders.forEach(order => {
                const orderId = order['Order ID'] || '';
                const time = order['Th·ªùi gian ƒë·∫∑t'] || '';
                const customer = order['T√™n kh√°ch/S·ªë b√†n'] || '';
                const items = order['Chi ti·∫øt m√≥n'] || '';
                const total = order['T·ªïng ti·ªÅn (K)'] || '';
                const notes = order['Ghi ch√∫'] || '';
                const status = order['Tr·∫°ng th√°i (Pending/Completed)'] || 'Pending';
                const statusClass = status.toLowerCase().includes('completed') ? 'status-completed' : status.toLowerCase().includes('cancelled') ? 'status-cancelled' : 'status-pending';

                html += `
                    <tr>
                        <td><strong>#${orderId}</strong></td>
                        <td>${time}</td>
                        <td>${customer}</td>
                        <td style="max-width: 200px; font-size: 0.9rem;">${items.replace(/;\n/g, '<br>')}</td>
                        <td><strong>${total}K</strong></td>
                        <td style="max-width: 150px; font-size: 0.9rem;">${notes}</td>
                        <td><span class="status-badge ${statusClass}">${status}</span></td>
                        <td>
                            ${status !== 'Completed' ? `<button class="btn btn-success" onclick="updateOrderStatus('${orderId}', 'Completed')">Ho√†n th√†nh</button>` : ''}
                            ${status !== 'Cancelled' ? `<button class="btn btn-danger" onclick="updateOrderStatus('${orderId}', 'Cancelled')">H·ªßy</button>` : ''}
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

	// C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng ho·∫∑c x√≥a ƒë∆°n h√†ng
        async function updateOrderStatus(orderId, newStatus) {
            try {
                const formData = new URLSearchParams();
                let actionType = 'updateOrderStatus'; // M·∫∑c ƒë·ªãnh l√† c·∫≠p nh·∫≠t tr·∫°ng th√°i

                if (newStatus === 'Cancelled') {
                    if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën X√ìA Vƒ®NH VI·ªÑN ƒë∆°n h√†ng #${orderId} kh√¥ng? Thao t√°c n√†y kh√¥ng th·ªÉ ho√†n t√°c.`)) {
                        return; // Ng∆∞·ªùi d√πng h·ªßy b·ªè thao t√°c x√≥a
                    }
                    actionType = 'deleteOrder'; // ƒê·ªïi action th√†nh 'deleteOrder' n·∫øu l√† 'Cancelled'
                }

                formData.append('action', actionType);
                formData.append('orderId', orderId);
                // Ch·ªâ th√™m status n·∫øu action kh√¥ng ph·∫£i l√† 'deleteOrder'
                if (actionType === 'updateOrderStatus') {
                    formData.append('status', newStatus);
                }

                const response = await fetch(SCRIPT_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData
                });
                const result = await response.json();

                if (result.success) {
                    if (actionType === 'deleteOrder') {
                        showMessage('üóëÔ∏è ƒê√£ x√≥a ƒë∆°n h√†ng #' + orderId + ' th√†nh c√¥ng!', 'success');
                    } else {
                        showMessage('‚úÖ ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng #' + orderId, 'success');
                    }
                    await loadOrders(); // T·∫£i l·∫°i danh s√°ch ƒë∆°n h√†ng
                    await loadStats(); // T·∫£i l·∫°i th·ªëng k√™
                } else {
                    throw new Error(result.error || 'Kh√¥ng th·ªÉ th·ª±c hi·ªán thao t√°c');
                }
            } catch (error) {
                console.error('L·ªói khi x·ª≠ l√Ω ƒë∆°n h√†ng:', error);
                showMessage('‚ùå L·ªói: ' + error.message, 'error');
            }
        }

        // Load menu
        async function loadMenu() {
            try {
                const response = await fetch(`${SCRIPT_URL}?action=getMenu`);
                const result = await response.json();
                if (result.success) {
                    currentMenu = result.data;
                    displayMenu(currentMenu);
                }
            } catch (error) {
                console.error('Error loading menu:', error);
                document.getElementById('menuContent').innerHTML = '<div class="error">L·ªói t·∫£i menu: ' + error.message + '</div>';
            }
        }

        // S·ª≠a l·∫°i h√†m displayMenu() ƒë·ªÉ hi·ªÉn th·ªã category
        function displayMenu(menu) {
            const container = document.getElementById('menuContent');
            if (!menu || menu.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 2rem;">Ch∆∞a c√≥ m√≥n n√†o trong menu</p>';
                return;
            }

            // Group menu theo category
            const categorized = {};
            menu.forEach(item => {
                const name = item['name'] || '';
                const price = item['price'] || '';
                const id = item['ID M√≥n'] || '';
                const category = item['category'] || 'KH√ÅC'; // Use category directly from item

                if (!categorized[category]) {
                    categorized[category] = [];
                }
                categorized[category].push({ id, name, price, category });
            });

            let html = '';
            // Hi·ªÉn th·ªã theo t·ª´ng category
            Object.keys(categorized).sort().forEach(category => {
                html += `
                    <div style="margin-bottom: 2rem;">
                        <h3 style="color: #2c3e50; border-bottom: 2px solid #e74c3c; padding-bottom: 0.5rem; margin-bottom: 1rem;">
                            ${getCategoryIcon(category)} ${category}
                        </h3>
                        <div class="menu-grid">
                `;

                categorized[category].forEach(item => {
                    html += `
                        <div class="menu-item-card">
                            <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 1rem;">
                                <h4 style="color: #2c3e50; margin: 0; flex: 1;">${item.name}</h4>
                                <span style="background: #e74c3c; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.8rem;">${item.category}</span>
                            </div>
                            <p style="font-size: 1.2rem; color: #e74c3c; font-weight: bold; margin-bottom: 1rem;">${item.price}K</p>
                            <div>
                                <button class="btn btn-primary" onclick="openEditDialog('${item.id}', '${item.name}', '${item.price}', '${item.category}')">S·ª≠a</button>
                                <button class="btn btn-danger" onclick="deleteMenuItem('${item.id}', '${item.name}')">X√≥a</button>
                            </div>
                        </div>
                    `;
                });
                html += '</div></div>';
            });
            container.innerHTML = html;
        }

        // Function ƒë·ªÉ l·∫•y icon cho category
        function getCategoryIcon(category) {
            const icons = {
                'CAFE': '‚òï',
                'N∆Ø·ªöC √âP': 'ü•§',
                'TR√Ä': 'üçÉ',
                'TR√Ä S·ªÆA': 'üßã',
                'S·ªÆA CHUA L·∫ÆC': 'ü•õ',
                'KH√ÅC': 'üçπ'
            };
            return icons[category] || 'üçπ';
        }

        // Function m·ªü dialog s·ª≠a m√≥n - C·∫≠p nh·∫≠t ƒë·ªÉ s·ª≠a c·∫£ t√™n v√† gi√°
        function openEditDialog(id, name, price, category) {
            // Dialog s·ª≠a t√™n
            const newName = prompt(`S·ª≠a t√™n m√≥n:\n(Hi·ªán t·∫°i: ${name})`, name);
            if (newName === null) return; // User cancelled

            // Dialog s·ª≠a gi√°
            const newPrice = prompt(`S·ª≠a gi√° m√≥n (ƒë∆°n v·ªã: K):\n(Hi·ªán t·∫°i: ${price}K)`, price);
            if (newPrice === null) return; // User cancelled

            // Validation
            if (!newName.trim()) {
                showMessage('T√™n m√≥n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!', 'error');
                return;
            }
            if (!newPrice.trim() || isNaN(newPrice) || parseInt(newPrice) <= 0) {
                showMessage('Gi√° m√≥n ph·∫£i l√† s·ªë d∆∞∆°ng!', 'error');
                return;
            }

            // G·ªçi function c·∫≠p nh·∫≠t
            updateMenuItem(id, newName.trim(), parseInt(newPrice), category);
        }

        // Function c·∫≠p nh·∫≠t m√≥n - G·ª≠i c·∫£ t√™n v√† gi√° m·ªõi
        async function updateMenuItem(itemId, name, price, category) {
            try {
                console.log(`Updating item: ID=${itemId}, Name=${name}, Price=${price}, Category=${category}`);
                const formData = new URLSearchParams();
                formData.append('action', 'updateMenuItem');
                formData.append('itemId', itemId);
                formData.append('name', name);
                formData.append('price', price);
                formData.append('category', category);

                const response = await fetch(SCRIPT_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData
                });
                const result = await response.json();

                if (result.success) {
                    showMessage(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t m√≥n "${name}" - ${price}K th√†nh c√¥ng!`, 'success');
                    await loadMenu(); // Reload menu ƒë·ªÉ hi·ªÉn th·ªã thay ƒë·ªïi
                } else {
                    throw new Error(result.error || 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t m√≥n');
                }
            } catch (error) {
                console.error('Error updating menu item:', error);
                showMessage('‚ùå L·ªói c·∫≠p nh·∫≠t m√≥n: ' + error.message, 'error');
            }
        }

        // Function x√≥a m√≥n - c·∫≠p nh·∫≠t l·∫°i
        async function deleteMenuItem(itemId, itemName) {
            if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a m√≥n "${itemName}"?`)) {
                return;
            }
            try {
                const formData = new URLSearchParams();
                formData.append('action', 'deleteMenuItem');
                formData.append('itemId', itemId);

                const response = await fetch(SCRIPT_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData
                });
                const result = await response.json();

                if (result.success) {
                    showMessage(`üóëÔ∏è ƒê√£ x√≥a m√≥n "${itemName}" th√†nh c√¥ng!`, 'success');
                    await loadMenu(); // Reload menu
                } else {
                    throw new Error(result.error || 'Kh√¥ng th·ªÉ x√≥a m√≥n');
                }
            } catch (error) {
                console.error('Error deleting menu item:', error);
                showMessage('‚ùå L·ªói x√≥a m√≥n: ' + error.message, 'error');
            }
        }

        // Th√™m m√≥n m·ªõi
        async function addNewMenuItem() {
            const name = document.getElementById('newItemName').value.trim();
            const price = document.getElementById('newItemPrice').value.trim();
            const category = document.getElementById('newItemCategory').value;

            if (!name) {
                showMessage('T√™n m√≥n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!', 'error');
                return;
            }
            if (!price || isNaN(price) || parseInt(price) <= 0) {
                showMessage('Gi√° m√≥n ph·∫£i l√† s·ªë d∆∞∆°ng!', 'error');
                return;
            }

            try {
                const formData = new URLSearchParams();
                formData.append('action', 'addMenuItem');
                formData.append('name', name);
                formData.append('price', parseInt(price));
                formData.append('category', category);

                const response = await fetch(SCRIPT_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData
                });
                const result = await response.json();

                if (result.success) {
                    showMessage(`‚ú® ƒê√£ th√™m m√≥n "${name}" - ${price}K v√†o menu!`, 'success');
                    document.getElementById('newItemName').value = '';
                    document.getElementById('newItemPrice').value = '';
                    document.getElementById('newItemCategory').value = 'CAFE'; // Reset v·ªÅ m·∫∑c ƒë·ªãnh
                    await loadMenu(); // Reload menu
                } else {
                    throw new Error(result.error || 'Kh√¥ng th·ªÉ th√™m m√≥n');
                }
            } catch (error) {
                console.error('Error adding new menu item:', error);
                showMessage('‚ùå L·ªói th√™m m√≥n m·ªõi: ' + error.message, 'error');
            }
        }

        // Show messages (success/error)
        function showMessage(message, type) {
            const msgBox = document.createElement('div');
            msgBox.className = type;
            msgBox.textContent = message;
            document.body.appendChild(msgBox);

            setTimeout(() => {
                msgBox.remove();
            }, 3000);
        }

        // Initialize date filter when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Set today as default if no filter selected
            setTimeout(() => {
                if (document.getElementById('dateFilter')) {
                    document.getElementById('dateFilter').value = 'today';
                    filterOrdersByDate();
                }
            }, 1000);
        });
        // Helper function for short status - TH√äM FUNCTION N√ÄY
        function getShortStatus(status) {
            if (status.toLowerCase().includes('completed')) return 'Xong';
            if (status.toLowerCase().includes('cancelled')) return 'H·ªßy';
            return 'Ch·ªù';
        }
    </script>
</body>
</html>
